tbl_b_idx <- grep("B.", keys)
if(!is.integer0(tbl_b_idx)) {
tbl_b_key <- keys[tbl_b_idx]
cset_b <- merge(bowker, cand_set, by.x = unlist(walmart@key), by.y = tbl_b_key)
}
cset_a_small <- cset_a[1:5, ]
cset_b_small <- cset_b[1:5, ]
View(cset_b_small)
fn_list <- create_features()
apply_feat_fn_over_2tables(cset_a_small, cset_b_small, fn_list)
View(cand_set)
cset_a_small
cset_a_small[1, "title"]
cset_b_small[1, "title"]
View(cset_a)
View(cand_set)
View(cand_set)
View(cset_a_small)
View(cset_a_small)
View(cset_a)
View(cand_set)
cand_set[23, ]
key[match(walmart["id"], cand_set["A.id"])]
key[match(walmart["id"], cand_set["A.id"]), ]
walmart[match(walmart["id"], cand_set["A.id"]), ]
cset_a_small["A.Id"]
cset_a_small["A.id"]
cset_a_smal["id"]
colnames(cset_a_small)
cset_a_smal[, "id"]
cset_a_small[, "id"]
match(cand_set[, "id"], cset_a_small["id"])
match(cand_set[, "id"], cset_a_small[, "id"])
match(cand_set[, "A.id"], cset_a_small[, "id"])
cand_set[match(cand_set[, "A.id"], cset_a_small[, "id"], )
)
cand_set[match(cand_set[, "A.id"], cset_a_small[, "id"], ]
cand_set[match(cand_set[, "A.id"], cset_a_small[, "id"]),  ]
match(cand_set[, "A.id"], cset_a_small[, "id"])
!is.na(match(cand_set[, "A.id"], cset_a_small[, "id"]))
kk <- !is.na(match(cand_set[, "A.id"], cset_a_small[, "id"]))
tt <- match(bowker[, "B.id"], cset_b_small[, "id"])
tt <- match(bowker[, "id"], cset_b_small[, "id"])
sort(tt)
tt1 <- nrow(tt)
tt1
tt1 <- seq(nrow(tt))
tt1
tt
tt[!is.na(tt)]
tt
tt[5]
bb <- bowker[tt[!is.na(tt)], ]
bb[1, "title"]
bb[, "title"]
merge.with.order <- function(x,y, ..., sort = T, keep_order = 1)
{
# this function works just like merge, only that it adds the option to return the merged data.frame ordered by x (1) or by y (2)
add.id.column.to.data <- function(DATA)
{
data.frame(DATA, id... = seq_len(nrow(DATA)))
}
# add.id.column.to.data(data.frame(x = rnorm(5), x2 = rnorm(5)))
order.by.id...and.remove.it <- function(DATA)
{
# gets in a data.frame with the "id..." column.  Orders by it and returns it
if(!any(colnames(DATA)=="id...")) stop("The function order.by.id...and.remove.it only works with data.frame objects which includes the 'id...' order column")
ss_r <- order(DATA$id...)
ss_c <- colnames(DATA) != "id..."
DATA[ss_r, ss_c]
}
# tmp <- function(x) x==1; 1	# why we must check what to do if it is missing or not...
# tmp()
if(!missing(keep_order))
{
if(keep_order == 1) return(order.by.id...and.remove.it(merge(x=add.id.column.to.data(x),y=y,..., sort = FALSE)))
if(keep_order == 2) return(order.by.id...and.remove.it(merge(x=x,y=add.id.column.to.data(y),..., sort = FALSE)))
# if you didn't get "return" by now - issue a warning.
warning("The function merge.with.order only accepts NULL/1/2 values for the keep_order variable")
} else {return(merge(x=x,y=y,..., sort = sort))}
}
merge.with.order(bowker, cand_set, by.x = "id", by.y = "B.id", keep_order = 2)
tt2 <- merge.with.order(bowker, cand_set, by.x = "id", by.y = "B.id", keep_order = 2)
tt2[1:5, "title"]
tt3 <- merge.with.order(walmart, cand_set, by.x = "id", by.y = "A.id", keep_order = 2)
tt3[1:5, "title"]
cset_a <- merge.with.order(walmart, cand_set, by.x = unlist(walmart@key), by.id = tbl_a_key, keep_order = 2)
cset_a <- merge.with.order(walmart, cand_set, by.x = unlist(walmart@key), by.y = tbl_a_key, keep_order = 2)
cset_b <- merge.with.order(bowker, cand_set, by.x = unlist(bowker@key), by.y = tbl_b_key, keep_order = 2)
cset_a[1:5, "title"]
cset_b[1:5, "title"]
apply_feat_fn_over_2tables(cset_a_small, cset_b_small, fn_list)
cset_a_small <- cset_a[1:5, ]
cset_b_small <- cset_b[1:5, ]
fn_list <- create_features()
feat_vec <- apply_feat_fn_over_2tables(cset_a_small, cset_b_small, fn_list)
feat_vec
c_set_a[, c("publisher", "title", "price")]
cset_a_small[, c("publisher", "title", "price")]
cset_a_small[, c("publisher", "title", "pages")]
cset_b_small[, c("publisher", "title", "pages")]
library(QPackage)
print("Importing walmart data")
walmart <- read_csv("../QPackage/inst//extdata/books/walmart.csv", status = read_status)
print(read_status)
# check id
status <- check_id(walmart, list("id"))
print(status)
# set id
status <- set_id(walmart, list("id"))
print(status)
# -- bowker
print("Importing bowker data")
bowker <- read_csv("../QPackage/inst//extdata/books/bowker.csv", status = read_status)
print(read_status)
# check id
status <- check_id(bowker, list("id"))
print(status)
status <- set_id(bowker, list("id"))
print(status)
attr1 <- "isbn"
cand_set <-  apply_block(walmart, bowker, attr_equiv_block, attr1, attr2, col_names_a = list("title", "author", "binding", "publisher", "pages"), col_names_b = list("title", "author", "binding", "publisher", "pages"))
attr2 <- "isbn"
cand_set <-  apply_block(walmart, bowker, attr_equiv_block, attr1, attr2, col_names_a = list("title", "author", "binding", "publisher", "pages"), col_names_b = list("title", "author", "binding", "publisher", "pages"))
is.integer0 <- function(x)
{
is.integer(x) && length(x) == 0L
}
merge.with.order <- function(x,y, ..., sort = T, keep_order = 1)
{
# took it from : http://www.r-statistics.com/2012/01/merging-two-data-frame-objects-while-preserving-the-rows-order/
# this function works just like merge, only that it adds the option to return the merged data.frame ordered by x (1) or by y (2)
add.id.column.to.data <- function(DATA)
{
data.frame(DATA, id... = seq_len(nrow(DATA)))
}
# add.id.column.to.data(data.frame(x = rnorm(5), x2 = rnorm(5)))
order.by.id...and.remove.it <- function(DATA)
{
# gets in a data.frame with the "id..." column.  Orders by it and returns it
if(!any(colnames(DATA)=="id...")) stop("The function order.by.id...and.remove.it only works with data.frame objects which includes the 'id...' order column")
ss_r <- order(DATA$id...)
ss_c <- colnames(DATA) != "id..."
DATA[ss_r, ss_c]
}
# tmp <- function(x) x==1; 1  # why we must check what to do if it is missing or not...
# tmp()
if(!missing(keep_order))
{
if(keep_order == 1) return(order.by.id...and.remove.it(merge(x=add.id.column.to.data(x),y=y,..., sort = FALSE)))
if(keep_order == 2) return(order.by.id...and.remove.it(merge(x=x,y=add.id.column.to.data(y),..., sort = FALSE)))
# if you didn't get "return" by now - issue a warning.
warning("The function merge.with.order only accepts NULL/1/2 values for the keep_order variable")
} else {return(merge(x=x,y=y,..., sort = sort))}
}
keys <- unlist(cand_set@key)
tbl_a_idx <- grep("A.", keys)
if(!is.integer0(tbl_a_idx)) {
tbl_a_key <- keys[tbl_a_idx]
#cset_a <- merge(walmart, cand_set, by.x = unlist(walmart@key), by.y = tbl_a_key)
cset_a <- merge.with.order(walmart, cand_set, by.x = unlist(walmart@key), by.y = tbl_a_key, keep_order = 2)
}
tbl_b_idx <- grep("B.", keys)
if(!is.integer0(tbl_b_idx)) {
tbl_b_key <- keys[tbl_b_idx]
#cset_b <- merge(bowker, cand_set, by.x = unlist(walmart@key), by.y = tbl_b_key)
cset_b <- merge.with.order(bowker, cand_set, by.x = unlist(bowker@key), by.y = tbl_b_key, keep_order = 2)
}
cset_a_small <- cset_a[1:5, ]
cset_b_small <- cset_b[1:5, ]
fn_list <- create_features()
feat_vec <- apply_feat_fn_over_2tables(cset_a_small, cset_b_small, fn_list)
feat_vec
library(dplyr)
tbl_df(feat_vec)
sample_cset <- sample_qtable(cand_set, 25)
label_cset <- label_data(sample_cset)
label_cset
colnames(label_cset)
lengthcolnames(label_cset)
length(colnames(label_cset))
colnames(label_cset)[13]
colnames(label_cset)[13] == "label"
sapply(label_cset, class)
as.factot(label_cset)
as.factor(label_cset)
as.factor(label_cset["label"])
as.factor(label_cset[, "label"])
sapply(label_cset, class)
levels(as.factor(label_cset[, "label"]))
length(levels(as.factor(label_cset[, "label"])))
any(label_cset[, "label"] < 0) || any(label_cset[, "label"]) > 1)
any(label_cset[, "label"] < 0)
any(label_cset[, "label"] > 1)
any(label_cset[, "label"] > 1) || TRUE
any(label_cset[, "label"] > 1) || FALSE
any(label_cset[, "label"] > 1) || any(label_cset[, "label"] < 0)
library(QPackage)
View(label_cset)
save(label_cset, file="../QPackage//data//test_label_cset.RData")
bowke_dataset <- bowker
bowker_bk_dataset <- bowker
walmart_bk_dataset <- walmart
save(bowker_bk_dataset, file="../QPackage//data//bowker_bk_dataset.RData")
save(walmart_bk_dataset, file="../QPackage//data//walmart_bk_dataset.RData")
fn_list <- create_features()
fn_list
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
is_qtable(walmart)
library(QPackage)
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
colnames(table_obj)
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
source('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/helper-functions.R')
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/helper-functions.R')
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
(any(table_obj[, "label"] < 0) || any(table_obj[, "label"]) > 1)
any(table_obj[, "label"]) < 0) || any(table_obj[, "label"]) > 1)
any(table_obj[, "label"]) < 0 || any(table_obj[, "label"]) > 1)
any(table_obj[, "label"]) < 0 || any(table_obj[, "label"]) > 1
any(table_obj[, "label"] < 0 )  || any(table_obj[, "label"] > 1)
feat_vec <- apply_feat_fn(walmart, bowker, label_cset, fn_list)
is_labeled_table(label_cset)
tt <- label_cset[, "label"] < 0
?any
any(table_obj[, "label"] < 0 )
any(label_cset[, "label"] < 0 )
any(label_cset[, "label"] < 0 ) || any(label_cset[, "label"] > 1)
any(label_cset[, "label"] < 0 ) | any(label_cset[, "label"] > 1)
source('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/helper-functions.R')
is_labeled_table(label_cset)
library(QPackage)
data(bowker_bk_dataset)
data(walmart_bk_dataset)
data(test_label_cset)
fn_list <- create_features()
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
library(QPackage)
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
View(feat_vec)
View(label_cset)
View(table_b)
feat_vec
202-106
library(QPackage)
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec
library(QPackage)
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec
debugSource('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
source('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/feature-generation.R')
library(QPackage)
feat_vec <- apply_feat_fn(walmart_bk_dataset, bowker_bk_dataset, label_cset, fn_list)
feat_vec
ff1 <- feat_vec
ff1[, "A.id"] <- as.character(ff[, "A.id"])
ff1[, "A.id"] <- as.character(ff1[, "A.id"])
ff1
as.character
install.packages("caret")
library("caret")
?train
install.packages("cvTools")
library(cvTools)
cvFolds(10, K = 5)
?cvFolds
ff <- cvFolds(10, K = 5)
ff
attributes(ff)
attr(ff, "subsets")
ff["subsets"]
ff
ff["which"]
ff <- cvFolds(4, K = 5)
ff <- cvFolds(5, K = 5)
ff
?createFolds
library(caret)
iris
split<-createDataPartition(y = mtcars$mpg, p = 0.6, list = FALSE)
dev<-mtcars[split,]
val<-mtcars[-split,]
dev
val
length(dev)
nrow(dev)
nrow(val)
lmFit <- train(mpg ~ ., data = dev, method = "lm")
lmFit
data(iris)
cvFit(rpart, formula=Species~., data=iris,
cost=function(y, yHat) (y != yHat) + 0, predictArgs=c(type='class'))
install.packages("rpart")
data(iris)
cvFit(rpart, formula=Species~., data=iris,
cost=function(y, yHat) (y != yHat) + 0, predictArgs=c(type='class'))
library(rpart)
data(iris)
cvFit(rpart, formula=Species~., data=iris,
cost=function(y, yHat) (y != yHat) + 0, predictArgs=c(type='class'))
data(iris)
cvFit(rpart, formula=Species~., data=iris,
cost=function(y, yHat) (y != yHat) + 0, folds = 5, predictArgs=c(type='class'))
?cvFit
f <- cvFit(rpart, formula=Species~., data=iris, cost=function(y, yHat) (y != yHat) + 0, predictArgs=c(type='class'))
f
summary(f)
f <- cvFit(rpart, formula=Species~., data=iris,  predictArgs=c(type='class'))
f <- cvFit(rpart, formula=Species~., data=iris)
f
3
4
5
6
7
8
9
10
11
12
# load the library
library(caret)
# load the iris dataset
data(iris)
# define training control
train_control <- trainControl(method="cv", number=10)
train_contro;
train_control
model <- train(Species~., data=iris, trControl=train_control, method="rf")
model <- train(Species~., data=iris, trControl=train_control, method="rf")
install.packages("e1071")
model <- train(Species~., data=iris, trControl=train_control, method="rf")
model
summary(model)
library(caret)
?createFolds
y <- 1:10
createFolds(y, 5)
createFolds(y, 10)
createFolds(y, 15)
createFolds(y, 3)
createFolds(y)
createFolds(1:100)
f <- cvFit(rpart, formula=Species~., data=iris, cost=function(y, yHat) (y != yHat) + 0, predictArgs=c(type='class'))
f
attributes(f)
f["cv"]
f["se"]
?train
?randomForest
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50)
summary(model)
model
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50, mtry=3)
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50, tuneGrid = data.frame(.mtry = M))
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50, tuneGrid = data.frame(.mtry = 3))
model
train
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50, tuneGrid = data.frame(.mtry = 3), k = 0)
?train
model <- train(Species~., data=iris, trControl=train_control, method="rf", ntree=50, tuneGrid = data.frame(.mtry = 3))
class(model)
attributes(model)
attributes(model$method)
?randomForest
summary(model)
mode$importance
mode$ntree
model$importance
model$finalModel
?trainControl
createFolds
cvFolds(1:20, K = 5)
?cvFolds
cvFolds(20, K = 5)
ff <- cvFolds(20, K = 5)
ff[1]
ff[2]
ff[3]
ff[34]
ff[4]
ff
ff$Fold
ff[["Fold"]]
?cvFolds
model$finalModel
?cvit
cvFit
?cvFit
?predict.randomForest
?predict.rpart
?predict.randomForest
?predict.rpart
?predict.glmrob
?predict.bag
?predict.avNNet
?predict.bagEarth
?randomForest
svm
?svm
# original example from Digg Data website (Takashi J. OZAKI, Ph. D.)
# http://diggdata.in/post/58333540883/k-fold-cross-validation-in-r
library(plyr)
library(randomForest)
data <- iris
# in this cross validation example, we use the iris data set to
# predict the Sepal Length from the other variables in the dataset
# with the random forest model
k = 5 #Folds
# sample from 1 to k, nrow times (the number of observations in the data)
data$id <- sample(1:k, nrow(data), replace = TRUE)
list <- 1:k
# prediction and testset data frames that we add to with each iteration over
# the folds
prediction <- data.frame()
testsetCopy <- data.frame()
#Creating a progress bar to know the status of CV
progress.bar <- create_progress_bar("text")
progress.bar$init(k)
for (i in 1:k){
# remove rows with id i from dataframe to create training set
# select rows with id i to create test set
trainingset <- subset(data, id %in% list[-i])
testset <- subset(data, id %in% c(i))
# run a random forest model
mymodel <- randomForest(trainingset$Sepal.Length ~ ., data = trainingset, ntree = 100)
# remove response column 1, Sepal.Length
temp <- as.data.frame(predict(mymodel, testset[,-1]))
# append this iteration's predictions to the end of the prediction data frame
prediction <- rbind(prediction, temp)
# append this iteration's test set to the test set copy data frame
# keep only the Sepal Length Column
testsetCopy <- rbind(testsetCopy, as.data.frame(testset[,1]))
progress.bar$step()
}
# add predictions and actual Sepal Length values
result <- cbind(prediction, testsetCopy[, 1])
names(result) <- c("Predicted", "Actual")
result$Difference <- abs(result$Actual - result$Predicted)
# As an example use Mean Absolute Error as Evalution
summary(result$Difference)
result
createFolds(1:20)
ff <- createFolds(1:20)
ff[[1]]
-ff[[1]]
ff <- createFolds(1:20, K = 7)
ff <- createFolds(1:20, k = 7)
ff
createFolds
library(devtools)
install.packages("devtools")
devtools::use_package("caret")
ff <- createFolds(1:20, k = 5, returnTrain = T)
ff
ff <- createFolds(1:20, k = 5, returnTrain = F)
ff
?cvFit
?train
?dvm
?svm
?randomForest
install.packages("ada")
?ada
library(ada)
?ada
?train
colnames(feat_vec)
colnames(feat_vec)[3:6]
train(feat_vec[, colnames(feat_vec)[3:6]], feat_vec[, "label"], method="rf")
train(feat_vec[, colnames(feat_vec)[3:6]], feat_vec[, "lbl_col"], method="rf")
train(feat_vec[, 3:6], feat_vec[, "lbl_col"], method="rf")
sapply(feat_vec, class)
train(feat_vec[, 3:6], as.factor(feat_vec[, "lbl_col"]), method="rf")
warnings()
train(feat_vec[, 3:6], as.factor(feat_vec[, "lbl_col"]), method="svm")
train(feat_vec[, 3:6], as.factor(feat_vec[, "lbl_col"]), method="svmLinear")
warnings()
is.formula
plyr::is.discrete
plyr::is.formula
source('C:/Pradap/Research/R-Packages/Q-RPackage/QPackage/R/crossvalidation.R')
label_cset
ll <- label_cset[1:5, -unlist(label_cset@key)]
ll <- label_cset[1:5, -(unlist(label_cset@key))]
which(colnames(label_cset), unlist(label_cset@key))
match(colnames(label_cset), unlist(label_cset@key))
grep(colnames(label_cset), unlist(label_cset@key))
grep(unlist(label_cset@key), colnames(label_cset))
?match
unlist(label_cset@key) %in% colnames(label_cset)
match(colnames(label_cset), unlist(label_cset@key), nomatch=0)
match(colnames(label_cset), unlist(label_cset@key), nomatch=NULL)
length(match(colnames(label_cset), unlist(label_cset@key)))
?createFolds
